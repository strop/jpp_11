-- This Happy file was machine-generated by the BNF converter
{
module Parlula where
import Abslula
import Lexlula
import ErrM
}

%name pProgram Program
%name pListStmt ListStmt
%name pExpr Expr
%name pNumb Numb
%name pStmt Stmt

-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype { Token }

%token 
 ';' { PT _ (TS ";") }
 '+' { PT _ (TS "+") }
 '=' { PT _ (TS "=") }
 '(' { PT _ (TS "(") }
 ')' { PT _ (TS ")") }
 'while' { PT _ (TS "while") }

L_integ  { PT _ (TI $$) }
L_ident  { PT _ (TV $$) }
L_err    { _ }


%%

Integer :: { Integer } : L_integ  { (read $1) :: Integer }
Ident   :: { Ident }   : L_ident  { Ident $1 }

Program :: { Program }
Program : ListStmt { Prog $1 } 


ListStmt :: { [Stmt] }
ListStmt : Stmt ';' { (:[]) $1 } 
  | Stmt ';' ListStmt { (:) $1 $3 }


Expr :: { Expr }
Expr : Numb { ENum $1 } 
  | Expr '+' Expr { EPlus $1 $3 }


Numb :: { Numb }
Numb : Integer { NumI $1 } 


Stmt :: { Stmt }
Stmt : Ident '=' Expr { SAssign $1 $3 } 
  | 'while' '(' Expr ')' Stmt { SWhile $3 $5 }



{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ if null ts then [] else (" before " ++ unwords (map prToken (take 4 ts)))

myLexer = tokens
}

